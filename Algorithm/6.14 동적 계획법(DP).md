# ë™ì  ê³„íšë²• (Dynamic Programming)

## ğŸ“Œ ë‚´ìš© ì •ë¦¬

### ë™ì  ê³„íšë²•ì´ë€?
- í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- ì‘ì€ ë¬¸ì œë“¤ì˜ ê²°ê³¼ë¥¼ ì €ì¥í•˜ì—¬ ë™ì¼í•œ ë¬¸ì œ ë°˜ë³µ ê³„ì‚°X
- ì¬ê·€ + ë©”ëª¨ì´ì œì´ì…˜ or ë°˜ë³µë¬¸ ì‚¬ìš©

---
### ì˜ˆì‹œ  
---

### ë°°ë‚­ ë¬¸ì œ, Knapsack problem (Bottom-Up)
- ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ ë°˜ë³µë¬¸ìœ¼ë¡œ í•´ê²°
- `dp[i][w]`ëŠ” ië²ˆì§¸ ì•„ì´í…œê¹Œì§€ ê³ ë ¤í–ˆì„ ë•Œ, ë°°ë‚­ ìš©ëŸ‰ wì—ì„œ ì–»ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜

```java
    public static int knapsack(int[] weights, int[] values, int W) {
        int n = weights.length;
        int[][] dp = new int[n + 1][W + 1];

        for (int i = 1; i <= n; i++) {
            for (int w = 0; w <= W; w++) {
                if (weights[i - 1] <= w) {
                    dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
                } else {
                    dp[i][w] = dp[i - 1][w];
                }
            }
        }
        return dp[n][W];
    }
```
---

### í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´, Top-Down

```java
private static Map<Integer, Long> memo = new HashMap<>();

    public static long fib(int n) {
        if (n <= 1) return n;
        if (memo.containsKey(n)) return memo.get(n);
        
        long result = fib(n - 1) + fib(n - 2);
        memo.put(n, result);
        
        return result;
    }
```